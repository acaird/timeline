{

  package timeline

  import "strings"
  import "time"
  import "fmt"
  import "github.com/acaird/timeline/pkg/parse"

}

File <- lines:(ImageSizeLine /
	       PeriodLine /
	       ScaleMajorLine /
	       Newline /
	       UnmatchedLine)* __ EOF
{
	var results []any

       // Iterate over the slice of results captured from the repetition (*)
       for _, lineResult := range lines.([]any) {
                if lineResult == "" || lineResult == nil {
                	   fmt.Println("skipping blank line")
                            continue
                }
		// Use a type switch to only collect ImageSize and Period structs, ignoring Newline results
		switch v := lineResult.(type) {
		case *parse.ImageSize:
        		fmt.Println("imagesize")
			results = append(results, v)
		case *parse.Period:
        		fmt.Println("period")
			results = append(results, v)
		case *parse.Scale:
        		fmt.Println("scale")
			results = append(results, v)
		// Newline results are discarded here
		default:
			// Optionally handle/log unmatched lines if needed
		}
	}
	return results, nil
}

ImageSizeLine <- "ImageSize" __ "=" __ attributes:Attributes __ EOL
{
    imageSize := &parse.ImageSize{}

    // Iterate over the attributes map collected by the Attributes rule
    for key, value := range attributes.(map[string]string) {
        switch strings.ToLower(key) {
        case "width":
            imageSize.Width = value
        case "height":
            imageSize.Height = value
        case "barincrement":
            imageSize.Barincrement = value
        }
    }
    // Return the populated struct
    return imageSize, nil
}

PeriodLine <- "Period" __ "=" __ attributes:Attributes __ EOL
{
    period := &parse.Period{}

    // Iterate over the attributes map collected by the Attributes rule
    for key, value := range attributes.(map[string]string) {
      fmt.Println(key)
      switch strings.ToLower(key) {
        case "from":
          period.From = value
        case "till":
          period.To = value
        }
    }
    return period, nil
}

// ScaleMajor = increment:5 start:1980
ScaleMajorLine <- "ScaleMajor" __ "=" __ attributes:Attributes __ EOL
{
    scaleMajor := &parse.Scale{}

    // Iterate over the attributes map collected by the Attributes rule
    for key, value := range attributes.(map[string]string) {
      fmt.Println(key)
      switch strings.ToLower(key) {
        case "increment":
  	  v, _ := strconv.Atoi(value)
          scaleMajor.Increment = v
        case "start":
  	  v, _ := strconv.Atoi(value)
          scaleMajor.Start = v
        }
    }
    return scaleMajor, nil
}

// The Attributes rule returns a map of all key-value pairs
Attributes <- first:Attribute others:(_ Attribute)*
{

	attributes := make(map[string]string)
	// Add the first attribute
	attributes[first.([]string)[0]] = first.([]string)[1]
	if others == nil {
		return attributes, nil // Handle the case where no optional attributes were found
	}
	othersSlice, ok := others.([]any)
	if !ok {
		othersSlice = others.([]interface{})
	}

	// Add the rest of the attributes
	for _, other := range othersSlice {
		attr := other.([]interface{})[1].([]string) // Extract the second element (the Attribute)
		attributes[attr[0]] = attr[1]
	}
	return attributes, nil
}

// The Attribute rule now returns a slice: [key, value]
Attribute <- key:Identifier __ ":" __ val:Value { return []string{key.(string), val.(string)}, nil }

// Identifier, Value, Number, _, __, and EOL remain the same

Identifier <- [a-zA-Z]+ { return string(c.text), nil }

Value <- Number / Auto

Number <- [0-9]+ { return string(c.text), nil }

Auto <- "auto" { return "auto", nil }

_ <- [ \t]+
__ <- [ \t]*
Newline <- [ \t]* "\n"

UnmatchedLine <- (!("\n") .)+ EOL
EOL <- "\n" / !.
EOF <- !.
